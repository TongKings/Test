
一、走进 java
jvm、jre、jdk
JVM不能单独搞定class的执行，解释class的时候JVM需要调用解释所需要的类库lib。在JDK下面的的jre目录里面有两个文件夹bin和lib,在这里可以认为bin里的就是jvm，
lib中则是jvm工作所需要的类库，而jvm和 lib和起来就称为jre。
JVM+Lib=JRE。总体来说就是，我们利用JDK（调用JAVA API）开发了属于我们自己的JAVA程序后，
通过JDK中的编译程序（javac）将我们的文本java文件编译成JAVA字节码，在JRE上运行这些JAVA字节码，
JVM解析这些字节码，映射到CPU指令集或OS的系统调用。
三者区别：
a.JDK和JRE区别：在bin文件夹下会发现，JDK有javac.exe而JRE里面没有，javac指令是用来将java文件编译成class文件的，这是开发者需要的，而用户（只需要运行的人）是不需要的。
JDK还有jar.exe, javadoc.exe等等用于开发的可执行指令文件。这也证实了一个是开发环境，一个是运行环境。
b.JRE和JVM区别：JVM并不代表就可以执行class了，JVM执行.class还需要JRE下的lib类库的支持，尤其是rt.jar。
c.我们主要看下rt.jar、dt.jar、tools.jar的作用，rt.jar在jre下的lib中，dt.jar和tools.jar在jdk的lib下。
rt.jar：Java基础类库，也就是Java doc里面看到的所有的类的class文件。
tools.jar：是系统用来编译一个类的时候用到的，即执行javac的时候用到。
dt.jar：dt.jar是关于运行环境的类库，主要是swing包
二、Java内存区域

* Java堆（Heap）：
是Java虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的主要目的就是存放对象实例，
还包括一部分数组对象，几乎所有的对象实例都在这里分配内存。可将堆分成新生代（Eden，From Survivor，To Survivor）、老年代两部分。
在堆中会发生OutOfMemoryError


<--------------------------------------------stackoverflow与outofmemoryError--------------------------------------------------------->

1、stackoverflow：
每当java程序启动一个新的线程时，java虚拟机会为他分配一个栈，java栈以帧为单位保持线程运行状态；当线程调用一个方法是，jvm压入一个新的栈帧到这个线程的栈中，只要这个方法还没返回，这个栈帧就存在。
如果方法的嵌套调用层次太多(如递归调用),随着java栈中的帧的增多，最终导致这个线程的栈中的所有栈帧的大小的总和大于-Xss设置的值，而产生生StackOverflowError溢出异常。

2、outofmemory：
2.1、栈内存溢出
java程序启动一个新线程时，没有足够的空间为改线程分配java栈，一个线程java栈的大小由-Xss设置决定；JVM则抛出OutOfMemoryError异常。
2.2、堆内存溢出
java堆用于存放对象的实例，当需要为对象的实例分配内存时，而堆的占用已经达到了设置的最大值(通过-Xmx)设置最大值，则抛出OutOfMemoryError异常。
2.3、方法区内存溢出
方法区用于存放java类的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。在类加载器加载class文件到内存中的时候，JVM会提取其中的类信息，并将这些类信息放到方法区中。
当需要存储这些类信息，而方法区的内存占用又已经达到最大值（通过-XX:MaxPermSize）；将会抛出OutOfMemoryError异常对于这种情况的测试，基本的思路是运行时产生大量的类去填满方法区，
直到溢出。这里需要借助CGLib直接操作字节码运行时，生成了大量的动态类。


常量池
u2             constant_pool_count;//常量池的数量
cp_info        constant_pool[constant_pool_count-1];//常量池
紧接着主次版本号之后的是常量池，常量池的数量是 constant_pool_count-1（常量池计数器是从1开始计数的，将第0项常量空出来是有特殊考虑的，索引值为0代表“不引用任何一个常量池项”）。
常量池主要存放两大常量：字面量和符号引用。
字面量比较接近于 Java 语言层面的的常量概念，如文本字符串、声明为 final 的常量值等。而符号引用则属于编译原理方面的概念。包括下面三类常量：
类和接口的全限定名
字段的名称和描述符
方法的名称和描述符
常量池中每一项常量都是一个表，这14种表有一个共同的特点：开始的第一位是一个 u1 类型的标志位 -tag 来标识常量的类型，代表当前这个常量属于哪种常量类型．

<------------------------------------------------------------------------------------------------------------------------------------------------------>


* 方法区（Method Area）：
与Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量（在运行时常量池中）、静态变量、即时编译器编译后的代码等数据。
此处也需要垃圾清理。运行时常量池：存放编译期的字面量和符号引用；JDK1.7及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。
在1.8之后用元数据空间（metaspace）代替实现了方法区，并将静态变量也移入java堆中。再此处也会发生OutOfMemoryError


<-----------------------------------------------永久代与metaspace的区别------------------------------------------------------>
持久代和metaspace(元数据空间)的区别：
持久代物理上处于堆的连续内存上，但是metaspace不再占用jvm的内存，而是直接占用本地内存，也就是说存储上限变为物理内存。
持久代在应用启动时，就已经确定了，很难进行调优；metaspace 直接占用本地内存，理论上，只要本地内存足够大，就可以无限占用，但是，metaspace也可以设置最大占用内存。
每个类加载器在metaspace中都有专门的存储空间，如果GC发现某个类加载器不再存活了，会把相关的空间整个回收掉，还给操作系统。
为什么用metaspace替换持久代：
字符串常量存在永久代中，容易出现性能问题和内存溢出。
类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难。
永久代会为 GC 带来不必要的复杂度，并且回收效率偏低
<----------------------------------------------------------------------------------------------------------------------------------------->

* 程序计数器（Program Counter Register）:

是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。
在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。

* JVM栈（JVM Stacks）,与程序计数器一样，Java虚拟机栈（Java Virtual Machine Stacks）也是线程私有的，它的生命周期与线程相同。
虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。
每一个方法被调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。
局部变量表所需内存空间在编译期完成分配，之后不会改变；存放数据类型（boolean、byte、char、short、int、float、long、double）、对象引用
会抛出StackOverflowError和OutOfMemoryError

* 本地方法栈（Native Method Stacks）,本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，
而本地方法栈则是为虚拟机使用到的Native方法服务。
会抛出StackOverflowError和OutOfMemoryError
<------------------------------------------------------------------------------------------------------------------------------->
在HotSpot jvm中，将本地方法栈与jvm栈合二为一了
<------------------------------------------------------------------------------------------------------------------------------->

2.1 对象创建过程：
1、虚拟机收到new指令
2、检查常量池中能否定位到一个类的符号引用
3、检查符号引用代表的类是否加载、解析和初始化过，没有就进行类的加载过程
4、为新生对象分配内存
5、将分配到的内存空间初始化为零值（不包括对象头）
6、对象头的储存信息设置
7、<init>初始化方法赋值

①类加载检查： 虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。
②分配内存： 在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。
        **内存分配的两种方式：（补充内容，需要掌握）分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择那种分配方式由 Java 堆是否规整决定。而 Java 堆内存是否规整，取决于 GC 收集器的算法是"标记-清除"，还是"标记-整理"（也称作"标记-压缩"），值得注意的是，复制算法内存也是规整的
        **内存分配并发问题（补充内容，需要掌握）在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：
               *** CAS+失败重试： CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。
               *** TLAB： 为每一个线程预先在Eden区分配一块儿内存，JVM在给线程中的对象分配内存时，首先在TLAB分配，当对象大于TLAB中的剩余内存或TLAB的内存已用尽时，再采用上述的CAS进行内存分配
③初始化零值： 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。
④设置对象头： 初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。
⑤执行 init 方法： 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<init> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后接着执行 <init> 方法，将对象属性值进行显示初始化并执行构造方法（调用子类<init> 方法之前会先调用父类<init> 方法）
 
存在继承的情况下，初始化顺序为：
父类（静态变量、静态语句块）——>
子类（静态变量、静态语句块）——>
父类（实例变量、父类普通语句块）———>父类（构造函数）——>
子类（实例变量、子类普通语句块）——>子类（构造函数）
<-------------------------------------------------------->
静态变量、静态语句块与实例变量、普通语句块按照它们各自顺序调用
通过隐式super()调用父类无参构造方法，若在创建对象时显式调用，那么将不会在调父类无参构造
<----------------------------------------------------->
![image](/home/tong/图片/jvm.png)
